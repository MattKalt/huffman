//compressed data
c = 0x00,

// huffman tree
// could definitely be encoded in a more optimized way
d = [],

//uncompressed output
o = '',

// Uncompress, ends when encountering ';'
u = (index, subtree) => (
	s = subtree[ (c >> index) & 1 ],
	s == ';' ?
		0
	: (
		Array.isArray(s) ?
			0
		: (
			o += s,
			s = d
		),
		u( index + 1, s)
	)
),

// Code used externally to generate huffman encoding:

function freqTable (str, chars = 1) {
	let table = {};
	for(i = 0; i < str.length; i++) { //
		ch = str.substring(i, i + chars - 1);
		if ( !table.hasOwnProperty(ch) ) table.ch = 1;
		else table.ch += 1;
	}
	return table
}

function freqTable (str, chars = 1) {
	let chrs = [];
  let freqs = [];
	for(i = 0; i < str.length; i++) { //
		ch = str.substring(i, i + chars);
    let idx;
    idx = chrs.indexOf(ch);
		if ( idx == -1) {
    	chrs.push(ch);
      freqs.push(1);
    }
		else freqs[idx] += 1;
	}
	let table = [];
  chrs.forEach( (e, i) => table.push( [chrs[i], freqs[i] ] ) );
  return table;
}

function sortTable (table) {
	return table.sort( (a,b) => b[1] - a[1]); //sort from highest to lowest freuqency
}

//input is [ reslt of chars=1, result of chars=2 ... ]
function abridge (arrays) {
	// lf = least-frequent of the highest-char array
	// find all the lower-char components
	// if the frequency of lf is the same as all the lower-char components:
	//		remove all the lower-char components
	// else:
	//		remove lf (?)
}

function huffmanTree (table) {
	while (table.length > 1) {
 		table.sort( (a,b) => b[1] - a[1] ); //highest to lowest freq
		a = table.pop();
		b = table.pop();
		ab = [ [ a[0], b[0] ], a[1] + b[1] ];
		//if I wanted more elegance I would insert in a way that doesn't require a full sort
		//but I don't
		table.push(ab);
	}
  return table[0][0]
	
}

test = "huffmanf";
console.log( huffmanTree( freqTable( test, 1 ) ) );
