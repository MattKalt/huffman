
function freqTable (str, chars = 1) {
	let table = {};
	for(let i = 0; i < str.length; i++) { //
		ch = str.substring(i, i + chars - 1);
		if ( !table.hasOwnProperty(ch) ) table.ch = 1;
		else table.ch += 1;
	}
	return table
}

function freqTable (str, chars = 1) {
	let chrs = [];
  let freqs = [];
	for(let i = 0; i < str.length; i++) { //
		ch = str.substring(i, i + chars);
    let idx;
    idx = chrs.indexOf(ch);
		if ( idx == -1) {
    	chrs.push(ch);
      freqs.push(1);
    }
		else freqs[idx] += 1;
	}
	let table = [];
  chrs.forEach( (e, i) => table.push( [chrs[i], freqs[i] ] ) );
  return table;
}

function sortTable (table) {
	return table.sort( (a,b) => b[1] - a[1]); //sort from highest to lowest freuqency
}

//input is [ reslt of chars=1, result of chars=2 ... ]
function abridge (arrays) {
	// lf = least-frequent of the highest-char array
	// find all the lower-char components
	// if the frequency of lf is the same as all the lower-char components:
	//		remove all the lower-char components
	// else:
	//		remove lf (?)
}

function huffmanTree (table) {
	while (table.length > 1) {
 		table.sort( (a,b) => b[1] - a[1] ); //highest to lowest freq
		a = table.pop();
		b = table.pop();
		ab = [ [ a[0], b[0] ], a[1] + b[1] ];
		//if I wanted more elegance I would insert in a way that doesn't require a full sort
		//but I don't
		table.push(ab);
	}
  return table[0][0]	
}

function encodeChar2 (ch, subtree, path="") {
	if (Array.isArray(subtree)) {
  	let output = "";
  	output += encodeChar (ch, subtree[0], path + '0'); 
  	output += encodeChar (ch, subtree[1], path + '1'); 
		return output
	} else if ( ch == subtree ) {
  	return path
	} else {
  	return ""
  }
}

function encodeChar3 (ch, subtree, path=0) {
	if ( Array.isArray(subtree) ) {
  	let output = 0;
  	output += encodeChar (ch, subtree[0], (path << 1) + 0); 
  	output += encodeChar (ch, subtree[1], (path << 1) + 1); 
		return output
	} else if ( ch == subtree ) {
  	return path
	} else {
  	return 0
  }
}

function encodeChar (ch, subtree, path=0, bits=0) {
	if ( Array.isArray(subtree) ) {
  	let o = 0;
    let b = bits + 1;
  	o += encodeChar (ch, subtree[0], path + (0 << bits), b); 
  	o += encodeChar (ch, subtree[1], path + (1 << bits), b); 
		return o
	} else if ( ch == subtree ) {
  	return path
	} else {
  	return 0
  }
}

function encode (text, huffTree) {
	let output = 0;
  let len = text.length;
  for (let i=0; i < len; i++) {
  	ch = text.substring( i, i + 1 );
  	//output += encodeChar( ch, huffTree) << i;
  	output = output << 1 + encodeChar( ch, huffTree) ;
}
  return output
}

test = "huffman;huffman";
testTree = huffmanTree( freqTable( test, 1 ) );
testEncoding = encode( test, testTree );
console.log( testTree );
console.log( testEncoding );

//c = eval( '0b' + testEncoding);
c = testEncoding;

d = testTree;

o = "";

u = (index, subtree) => (
	s = subtree[ (c >> index) & 1 ],
	s == ';' ?
		0
	: (
		Array.isArray(s) ?
			0
		: (
			o += s,
			s = d
		),
		u( index + 1, s)
	)
);

u( 0, d );

console.log( o );
