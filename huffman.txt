//compressed data
c = 0x00,

// huffman tree
// could definitely be encoded in a more optimized way
d = [],

//uncompressed output
o = '',

// Uncompress, ends when encountering ';'
u = (index, subtree) => (
	s = subtree[ (c >> index) & 1 ],
	s == ';' ?
		0
	: (
		Array.isArray(s) ?
			0
		: (
			o += s,
			s = d
		),
		u( index + 1, s)
	)
),


function freqTable (str, chars = 1) {
	let chrs = [];
  let freqs = [];
	for(i = 0; i < str.length; i++) { //
		ch = str.substring(i, i + chars);
    let idx;
    idx = chrs.indexOf(ch);
		if ( idx == -1) {
    	chrs.push(ch);
      freqs.push(1);
    }
		else freqs[idx] += 1;
	}
	let table = [];
  chrs.forEach( (e, i) => table.push( [chrs[i], freqs[i] ] ) );
  return table;
}

function sortTable (table) {
	let arrayForm = [];
	for( var key in table) {
		arrayForm.push( key, table[key] );
	}
	arrayForm.sort( (a,b) => b[1] - a[1]); //sort from highest to lowest freuqency
	return arrayForm
},

//input is [ reslt of chars=1, result of chars=2 ... ]
function abridge (arrays) {
	// lf = least-frequent of the highest-char array
	// find all the lower-char components
	// if the frequency of lf is the same as all the lower-char components:
	//		remove all the lower-char components
	// else:
	//		remove lf (?)
},

function huffmanTree (sortedFreq) {
	while (sortedFreq.length > 1) {
		a = sortedFreq.pop();
		b = sortedFreq.pop();
		ab = [ [ a[0], b[0] ], a[1] + b[1] ];
		//if I wanted more elegance I would insert in a way that doesn't require a full sort
		//but I don't
		sortedFreq.push(ab);
		sortedFreq.sort( (a,b) => b[1] - a[1] );
	}
	
},

t
